---
title: Generate-Java-unit-testsgoogle.com/vertex-ai/generative-ai/docs/prompt-gallery/samples/code_generate_java_unit_tests
date_scraped: 2025-05-12
---

# Generate Java unit tests 

Generate unit tests for legacy Java code

| | |
| --- | --- |
| You can query a model directly and test the results returned when using different parameter values with the Cloud console, or by calling the Vertex AI API directly. - For an example of using the Vertex AI API, see [Quickstart using the Vertex AI API](../../start/quickstarts/api-quickstart.md). - To view this sample in the Cloud console: [Go to Google Cloud console](https://console.cloud.google.com/vertex-ai/generative/language/prompt-examples/Generate%20Java%20unit%20tests) | |
| | | | --- | | **System instructions** | | | You are a proficient Java developer and an expert in Test-Driven development. Your primary goal is to write clean, efficient, and maintainable Java code and to ensure that all functionalities are thoroughly tested. | Prompt Freeform I am a Java developer and I have been following the test-driven development methodology. I have the following code that is used to operate a robot, which I am going to refactor soon to add the cleaning functionality. As a way to ensure that I do not break anything during the refactoring process and to understand the behavior of the code, I want to add some characterization tests to the existing code. - Refer to the following code and write unit tests using JUnit 4 for the methods in the `RoboCleaner` class. - Please make sure that you provide meaningful names to the tests, and cover any edge cases. ```python public class RoboCleaner { int x, y; Direction direction; public RoboCleaner(int initialX, int initialY, Direction initialDirection) { this.x = initialX; this.y = initialY; this.direction = initialDirection; } public void moveForward(int steps) { switch (direction) { case NORTH: y += steps; break; case SOUTH: y -= steps; break; case EAST: x += steps; break; case WEST: x -= steps; break; } } public void turnLeft() { direction = direction.turnLeft(); } public void turnRight() { direction = direction.turnRight(); } public String getPosition() { return String.format("Position: (%d, %d), Facing: %s", x, y, direction); } public enum Direction { NORTH, EAST, SOUTH, WEST; private static final Direction[] leftTurns = {WEST, NORTH, EAST, SOUTH}; private static final Direction[] rightTurns = {EAST, SOUTH, WEST, NORTH}; public Direction turnLeft() { return leftTurns[ordinal()]; } public Direction turnRight() { return rightTurns[ordinal()]; } } } ``` Response ```python import org.junit.Before; import org.junit.Test; import static org.junit.Assert.assertEquals; public class RoboCleanerTest { private RoboCleaner roboCleaner; @Before public void setUp() { roboCleaner = new RoboCleaner(0, 0, RoboCleaner.Direction.NORTH); } @Test public void testInitialPosition() { assertEquals("Position: (0, 0), Facing: NORTH", roboCleaner.getPosition()); } @Test public void testMoveForwardNorth() { roboCleaner.moveForward(5); assertEquals("Position: (0, 5), Facing: NORTH", roboCleaner.getPosition()); } @Test public void testMoveForwardSouth() { roboCleaner.direction = RoboCleaner.Direction.SOUTH; roboCleaner.moveForward(3); assertEquals("Position: (0, -3), Facing: SOUTH", roboCleaner.getPosition()); } @Test public void testMoveForwardEast() { roboCleaner.direction = RoboCleaner.Direction.EAST; roboCleaner.moveForward(7); assertEquals("Position: (7, 0), Facing: EAST", roboCleaner.getPosition()); } @Test public void testMoveForwardWest() { roboCleaner.direction = RoboCleaner.Direction.WEST; roboCleaner.moveForward(2); assertEquals("Position: (-2, 0), Facing: WEST", roboCleaner.getPosition()); } @Test public void testMoveForwardZeroSteps() { roboCleaner.moveForward(0); assertEquals("Position: (0, 0), Facing: NORTH", roboCleaner.getPosition()); } @Test public void testMoveForwardNegativeSteps() { roboCleaner.moveForward(-5); //Should not affect position assertEquals("Position: (0, 0), Facing: NORTH", roboCleaner.getPosition()); } @Test public void testTurnLeft() { roboCleaner.turnLeft(); assertEquals("Position: (0, 0), Facing: WEST", roboCleaner.getPosition()); } @Test public void testTurnLeftFromWest() { roboCleaner.direction = RoboCleaner.Direction.WEST; roboCleaner.turnLeft(); assertEquals("Position: (0, 0), Facing: SOUTH", roboCleaner.getPosition()); } @Test public void testTurnRight() { roboCleaner.turnRight(); assertEquals("Position: (0, 0), Facing: EAST", roboCleaner.getPosition()); } @Test public void testTurnRightFromEast() { roboCleaner.direction = RoboCleaner.Direction.EAST; roboCleaner.turnRight(); assertEquals("Position: (0, 0), Facing: SOUTH", roboCleaner.getPosition()); } @Test public void testMultipleTurns() { roboCleaner.turnLeft(); roboCleaner.turnRight(); roboCleaner.turnRight(); assertEquals("Position: (0, 0), Facing: EAST", roboCleaner.getPosition()); } @Test public void testComplexMovement() { roboCleaner.moveForward(2); roboCleaner.turnRight(); roboCleaner.moveForward(3); roboCleaner.turnLeft(); roboCleaner.moveForward(1); assertEquals("Position: (3, 3), Facing: NORTH", roboCleaner.getPosition()); } @Test public void testNegativeCoordinates(){ roboCleaner = new RoboCleaner(-1,-2, RoboCleaner.Direction.SOUTH); roboCleaner.moveForward(1); assertEquals("Position: (-1, -3), Facing: SOUTH", roboCleaner.getPosition()); } } ``` | | | | | --- | --- | | **Model:** | gemini-1.5-flash-002 | | **Temperature:** | 0.2 | | **Max output tokens:** | 8192 | | **TopK:** | 40.0 | | **TopP:** | 0.95 | |