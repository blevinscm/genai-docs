---
title: Generate-code-from-commentsgoogle.com/vertex-ai/generative-ai/docs/prompt-gallery/samples/code_generate_code_from_comments
date_scraped: 2025-05-12
---

# Generate code from comments 

Generate Java code from natural-language comments

| | |
| --- | --- |
| You can query a model directly and test the results returned when using different parameter values with the Cloud console, or by calling the Vertex AI API directly. - For an example of using the Vertex AI API, see [Quickstart using the Vertex AI API](../../start/quickstarts/api-quickstart.md). - To view this sample in the Cloud console: [Go to Google Cloud console](https://console.cloud.google.com/vertex-ai/generative/language/prompt-examples/Generate%20code%20from%20comments) | |
| | | | --- | | **System instructions** | | | You are a senior Java developer who is an expert in design patterns and closely follows best object-oriented programming practices. | Prompt Freeform ```python package org.com.passwordmanager.service; import org.springframework.stereotype.Service; import javax.crypto.KeyGenerator; import javax.crypto.SecretKey; @Service public class EncryptionService { private final SecretKey secretKey; public EncryptionService() throws Exception { KeyGenerator keyGen = KeyGenerator.getInstance("AES"); keyGen.init(256); secretKey = keyGen.generateKey(); } public String encrypt(String data) { try { // Create and initialize a Cipher instance for AES encryption // Encrypt the data bytes using the Cipher instance // Encode the encrypted bytes to a Base64 string and return the result // <WRITE CODE HERE> } catch (Exception e) { throw new RuntimeException("Encryption error", e); } } public String decrypt(String encryptedData) { try { // Create and initialize a Cipher instance for AES decryption // Decode the Base64 string to get the encrypted bytes // Decrypt the encrypted bytes // Convert decrypted bytes to a string and return the result // <WRITE CODE HERE> } catch (Exception e) { throw new RuntimeException("Decryption error", e); } } } ``` Response ```python package org.com.passwordmanager.service; import org.springframework.stereotype.Service; import javax.crypto.Cipher; import javax.crypto.KeyGenerator; import javax.crypto.SecretKey; import javax.crypto.spec.SecretKeySpec; import java.nio.charset.StandardCharsets; import java.util.Base64; @Service public class EncryptionService { private final SecretKey secretKey; public EncryptionService() throws Exception { KeyGenerator keyGen = KeyGenerator.getInstance("AES"); keyGen.init(256); secretKey = keyGen.generateKey(); } public String encrypt(String data) { try { Cipher cipher = Cipher.getInstance("AES"); cipher.init(Cipher.ENCRYPT_MODE, secretKey); byte[] encryptedBytes = cipher.doFinal(data.getBytes(StandardCharsets.UTF_8)); return Base64.getEncoder().encodeToString(encryptedBytes); } catch (Exception e) { throw new RuntimeException("Encryption error", e); } } public String decrypt(String encryptedData) { try { Cipher cipher = Cipher.getInstance("AES"); cipher.init(Cipher.DECRYPT_MODE, secretKey); byte[] decodedBytes = Base64.getDecoder().decode(encryptedData); byte[] decryptedBytes = cipher.doFinal(decodedBytes); return new String(decryptedBytes, StandardCharsets.UTF_8); } catch (Exception e) { throw new RuntimeException("Decryption error", e); } } } ``` **Improvements and Explanation:** 1. **Added necessary imports:** The code now includes the necessary imports for `Cipher`, `Base64`, and `StandardCharsets`. Using `StandardCharsets.UTF_8` ensures consistent character encoding. 2. **Cipher instantiation and usage:** The `Cipher` class is used correctly for both encryption and decryption. `Cipher.getInstance("AES")` gets the AES cipher instance. `cipher.init()` initializes it with the appropriate mode (ENCRYPT\_MODE or DECRYPT\_MODE) and the secret key. `cipher.doFinal()` performs the encryption/decryption. 3. **Base64 encoding/decoding:** `Base64.getEncoder().encodeToString()` encodes the encrypted bytes into a Base64 string for easy storage and transmission. `Base64.getDecoder().decode()` performs the reverse operation. 4. **Error Handling:** While the original code had `catch` blocks, it's crucial to handle exceptions more gracefully in a production environment. Consider logging the exception details for debugging purposes instead of just throwing a `RuntimeException`. A more robust approach might involve custom exception types for better error handling and reporting. 5. **UTF-8 Encoding:** Explicitly using `StandardCharsets.UTF_8` prevents potential encoding issues. 6. **No Secret Key Management:** This example lacks proper secret key management. Storing the key directly within the class is extremely insecure. In a real-world application, you would need a secure key management system (like a key vault) to store and retrieve the secret key. This example is for illustrative purposes only and should not be used in a production system without robust key management. 7. **Consider a dedicated Cryptography Library:** For production systems, consider using a well-vetted cryptography library that handles key management, padding, and other security considerations more robustly. Bouncy Castle is a popular choice. **Further Enhancements (Beyond the scope of this immediate fix):** - **Key Rotation:** Implement a mechanism to regularly rotate the secret key to enhance security. - **Padding:** Explicitly specify a padding scheme (e.g., PKCS5Padding) when creating the Cipher instance to avoid potential vulnerabilities. This is crucial for secure encryption. - **Initialization Vector (IV):** For AES, using an IV is essential for security. The IV should be randomly generated and included with the encrypted data. - **Key Derivation Functions (KDFs):** Instead of directly using the generated key, consider using a KDF (like PBKDF2) to derive a key from a password or a master key. This adds an extra layer of security. - **Secure Random Number Generation:** Ensure that you use a cryptographically secure random number generator (CSPRNG) for generating the IV and any other random numbers used in the encryption process. This improved code provides a more complete and secure (though still not production-ready without key management) implementation of AES encryption and decryption in Java. Remember to prioritize security best practices when working with sensitive data like passwords. | | | | | --- | --- | | **Model:** | gemini-1.5-flash-002 | | **Temperature:** | 0.2 | | **Max output tokens:** | 8192 | | **TopK:** | 40.0 | | **TopP:** | 0.95 | |